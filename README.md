# Stewart Platform Actuator Control System (STM32)

本项目是一个基于 **STM32** 的高性能六自由度并联平台（Stewart Platform）执行器控制系统。针对无硬限位、带增量式编码器的直流电缸设计，实现了高动态响应的**位置-速度串级 PID** 控制算法。

---

## 核心特性

- **串级 PID 控制**：采用“外环位置、内环速度”架构，有效抑制机械惯性导致的过冲。
- **感知层重构**：
    - **硬件编码器量化**：支持 16/32 位定时器溢出处理，实现脉冲到物理单位（mm）的精准转换。
    - **速度平滑**：内置 5 阶滑动窗口均值滤波器（Moving Average Filter），消除二阶微分噪声。
- **智能回零 (Homing)**：采用“堵转检测法”，在无额外限位开关的情况下自动找寻机械零点并重置编码器。
- **15AS 驱动器优化**：针对驱动器特性实现了 **1200-4198 PWM 映射**，包含起动死区补偿。
- **实时调试接口**：支持通过 UART 指令实时修改 PID 参数及目标位置，适配 **VOFA+ (FireWater)** 协议进行波形监控。

---

## 硬件配置

| 组件 | 规格 | 描述 |
| :--- | :--- | :--- |
| **控制器** | STM32F407 | 系统主控，10ms 定时中断控制频率 |
| **驱动器** | 15AS DC Driver | 双通道电平控制 (IN1/IN2) + PWM 调速 |
| **电缸** | 50mm 行程 | 带增量式编码器 (建议开启定时器硬件编码器模式) |
| **通信** | USART1 | 波特率 115200, 8-N-1 |

---

## 代码层级结构

系统控制逻辑被拆分为三个独立层级，位于 `actuator.c` 中：

1. **`Actuator_UpdateStatus` (感知层)**
   - 读取硬件编码器，计算 `current_pos`。
   - 通过位置差分并配合窗口滤波计算平滑的 `current_vel`。
2. **`Actuator_PositionControl` (规划层)**
   - 根据位置误差乘以 `kp_pos` 生成目标速度 `target_vel`。
   - 包含位置死区逻辑，防止终点震荡。
3. **`Actuator_VelocityControl` (执行层)**
   - 速度 PI(D) 计算，输出最终 PWM 和方向。
   - 包含积分限幅 (Anti-Windup) 和驱动器死区补偿。

---

## 串口调试指令

请使用串口助手或上位机发送以下格式指令（需以 `\r\n` 结尾）：

### 1. 位置控制
- `1=25.0` : 将 1 号缸移动到 25.0mm 位置。
- `all=20,20,20,20,20,20` : 6 轴同步移动（预留接口）。

### 2. PID 参数实时调节
- `kp=15.5` : 修改当前运行中的速度环比例系数 $K_{p\_vel}$。
- `ki=0.01` : 修改速度环积分系数 $K_{i\_vel}$。

---

## 调试参考波形



### 常见问题解决 (Troubleshooting)

| 现象 | 原因分析 | 解决方案 |
| :--- | :--- | :--- |
| **上电抖动剧烈** | 速度环 $K_p$ 过高 | 将 `kp_vel` 降至 5.0-15.0 区间。 |
| **终点持续微震** | 位置误差在死区边缘跳变 | 增加位置死区判断（如 `if(fabs(error)<0.1)` 强制停机）。 |
| **到位后有过冲** | 速度环响应滞后 | 减小滤波窗口长度，或适当增加速度环 $K_d$ 或位置环 $K_p$ 减小。 |
| **数值出现几百亿** | 缺少数学库或打印溢出 | 确保包含 `math.h` 并检查 `printf` 浮点数支持。 |

---

## 快速上手

1. **初始化**：在 `main.c` 调用 `Actuator_Init` 绑定硬件引脚。
2. **回零**：调用 `Actuator_ManualHome` 进行原点校准。
3. **闭环**：开启 `TIM6` 10ms 中断，并在回调函数中依次调用更新、位置控制、速度控制函数。
```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM6) {
        Actuator_UpdateStatus(&acts[0], Encoder_GetPos_mm(0));
        Actuator_PositionControl(&acts[0]);
        Actuator_VelocityControl(&acts[0]);
    }
}
